使用管道要注意以下几种特殊情况（假设都是阻塞I/O操作）

1. 所有指向管道**写端**的文件描述符都关闭了（管道写端引用计数为0），有进程从管道读端读数据，如果管道有剩余数据，则读取，读完后再次read会返回0，就像读到文件末尾一样。

2. 如果有指向管道**写端**的文件描述符没有关闭（管道写端引用计数大于0），而持有管道写端的进程也没有往管道写数据，这时候如果有进程从管道读端读数据，那么管道中剩余的数据会被读取，之后再次read会阻塞，直到管道中有数据才可以读取并返回

3. 如果所有指向管道**读端**的文件描述符关闭了（管道读端应用计数为0），如果有进程往管道中写数据，该进程会收到一个SIGPIPE，通常会导致进程异常终止

4. 如果所有指向管道**读端**的文件描述符没有关闭（管道读端应用计数大于0），而持有管道读端的进程没有读取数据，此时有进程往管道中写数据，那么在管道写满的时候再次write会阻塞，直到管道中空位置，才可以写入

总结：
	读管道：
		管道中有数据：read返回实际读到的字节数
		管道中无数据：
		    写端全部关闭，read返回0（读到文件末尾）
		    写端没有完全关闭：read阻塞等待
	写管道：
		管道读端全部关闭，进程异常终止
		管道读端没有完全关闭：
			管道已满：write阻塞
			管道未满：正常写入，并返回实际写入字节数

### 设置管道非阻塞
```c
int flags = fcntl(fd,F_GETFL); //获取原来的flag
flags |=O_NONBLOCK;          //修改flag
fcntl(fd,F_SETFL,flags);   //设置新的flags
```
