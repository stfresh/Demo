### 可以用来干什么
就是当**模式串**和**比较串**出现不匹配时，我们可以记录之前比较过的部分，这样就不用每次都再从**模式串**的第一个字符比较。

### 前缀表
**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**
**当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，**模式串** **应该跳到哪个位置**。

### 前缀和后缀
**前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串**。

**后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串**。


#### 例子
要在**比较串**：aabaabaafa 中查找是否出现过一个**模式串**：aabaaf。

##### 动画演示
https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B21.gif

匹配的过程在下标5的地方遇到不匹配，模式串是指向f
![[Pasted image 20221116153718.png |400]]

然后就找到了下标2，指向b，继续匹配：
![[Pasted image 20221116153822.png |400]]

#### 为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配？
**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面从新匹配就可以了。**
```c
因为是最长的相等的前后缀，又因为是在后缀的后面失败了，说明前缀和后缀是匹配上了的，那么我们就可以跳到前缀（模式串）的后面，再与待比较串刚才失败的位置匹配,（这样我们的比较串的后缀就变成前面的头部了）。
```

### 如何计算前缀表
![[Pasted image 20221116161617.png]]

### 前缀表的利用演示
https://code-thinking.cdn.bcebos.com/gifs/KMP%E7%B2%BE%E8%AE%B22.gif

### 时间复杂度分析
其中n为待比较串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

### 如何构造next数组（计算前缀表）
#### 不减一实现
```c++
void getnext(int *next,const string &s){
		/**  处理三种情况：i 我想成后缀，j我想成前缀，i从 1开始
		*一、初始化，第一个字符前后缀为空，所以为0
		*二、前缀不等于后缀，就回退前缀j,
		*三、前后缀相等，前缀j加一，把j值赋给next[i]
		*/
		//初始化
		int j=0;
		next[0]=j;
		for(int i=1; i<s.size();i++){
			while(j>0 &&s[j]!=s[i]){
				j=next[j-1];
			}
			if(s[j]==s[i])
				j++;
				
			next[i]=j;
		}
}
```

