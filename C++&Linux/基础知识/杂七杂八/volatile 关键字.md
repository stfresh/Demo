	A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.

	易失性说明符是对编译器的提示，即对象可能会以语言未指定的方式更改其值，因此必须避免激进的优化。

## 说明
volatile 关键字是一种**类型修饰符**，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对**特殊地址的稳定访问**。当要求使用 volatile 声明的变量的值的时候，系统总是重新从它**所在的内存读取数据。**

### 举个栗子
```
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作（就是背着编译器对i干了坏事）
int b = i;
```
1. volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。
2. 但是如果没有 volatile 关键字，编译器对访问的代码进行了优化的话，编译器不知道有人对i做了手脚，那么它看见上面a 读过 i，那就把a 给 b。
3. 这样如果 i 是一个**寄存器变量或者表示一个端口数据**就容易出错，因为它会被上面所说的（编译器）未知因素改变

```c++
#include <stdio.h>
 
void main()
{
    int i = 10;   //没有volatile
    int a = i;
 
    printf("i = %d", a);
 
    // 下面汇编语句的作用就是改变内存中 i 的值
    // 但是又不让编译器知道
    __asm {
        mov dword ptr [ebp-4], 20h
    }
 
    int b = i;
    printf("i = %d", b);
}

```
**Debug版输出：**
```
i = 10
i = 32
```

**Release版输出：**
```
i = 10
i = 10
```

**加上volatile后，两个都输出**
```
i = 10
i = 32
```
其实不只是内嵌汇编操纵栈"这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方：
-   1) 中断服务程序中修改的供其它程序检测的变量需要加 volatile；
-   2) 多任务环境下各任务间共享的标志应该加 volatile；
-   3) 存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；


## Release 和 Debug

#### Debug 版本（不做优化）
	Debug 是“调试”的意思，Debug 版本就是为调试而生的，编译器在生成 Debug 版本的程序时会加入调试辅助信息，并且很少会进行优化，程序还是“原汁原味”的。

#### Release 版本（竭尽全力优化）
	Release 是“发行”的意思，Release 版本就是最终交给用户的程序，编译器会使尽浑身解数对它进行优化，以提高执行效率，虽然最终的运行结果仍然是我们期望的，但底层的执行流程可能已经改变了。

编译器还会尽量降低 Release 版本的体积，把没用的数据一律剔除，包括调试信息。

最终，Release 版本是一个小巧精悍、非常纯粹、为用户而生的程序。

### 总结
Debug 版本的存在是为了方便程序员开发和调试，性能和体积不是它的重点；Release 版本是最终交给用户的程序，性能和体积是需要重点优化的两个方面。  
  
在开发过程中，我们一般使用 Debug 版本，只有等到开发完成，确认没有任何 Bug 之后，希望交给用户时再生成 Release 版本。