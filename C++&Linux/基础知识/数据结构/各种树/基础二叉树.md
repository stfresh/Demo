[链接](https://blog.csdn.net/qq_35644234/article/details/53013738)
### 1.二叉树的性质
-   在二叉树的第i层，至多有$2^{i-1}$个结点
-   深度为k的二叉树至多有：$2^k-1$个结点，其实这个结果就是一个等比数列的求和得到的。
-   对任意一颗二叉树，如果其叶子结点数量为：$n_0$,度为2的结点数为：$n_2$，则：$n_0=n_2+1$
	$n_0+n_1+n_2=n_1+2*n_2+1$
- 具有n个结点的完全二叉树的深度为：[log2n]+1，其中[log2n]+1是向下取整

![[Pasted image 20221028195519.png]]
**完全二叉树结点的位置和数值要和满二叉树一 一对应，所以只能有右边缺一些**

- 有N个结点的完全二叉树各结点如果用**顺序方式存储**，则结点之间有如下关系：
　1. 若i为结点编号则 如果i>1，则其父结点的编号为[i/2]，[i/2]是往下取整的；
　2. 如果2i<=N，则其左儿子（即左子树的根结点）的编号为2i；若2i>N，则无左儿子；
　3. 如果2i+1<=N，则其右儿子的结点编号为2i+1；若2i+1>N，则无右儿子。

###  2.二叉树的存储结构
#### （1）顺序存储结构：
顺序存储结构其实就是**用数组存**，从根结点开始，像对完全二叉树编号的顺序一样，把我们的二叉树的内容存储在一个一维数组中。一般顺序存储结构是拿来存储完全二叉树的，但是也可以拿来存储一般的二叉树，只是要按照完全二叉树的规则来编号，**如果没有的就存0**。

（这张的索引有点问题）
![[Pasted image 20221028200549.png]]

看这张，**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**
所以，对于a为根节点，它的下标为0，那么对应的它的左孩子在数组中就是，2*0+1 = 1，那就是b。
![[Pasted image 20221126142650.png |500]]

### （2）链式存储结构（比较常用一种存储结构）

二叉链表：数据域和两个指针域，一个指向左孩子，另一个指向右孩子
三叉链表：添加一个指针域，指向其父亲结点

![[Pasted image 20221028200721.png]]

### 3.遍历二叉树
#### 深度优先遍历
-   先/前序遍历（DLR）  
    （1）先访问根结点  
    （2）先序遍历左子树  
    （3）先序遍历右子树
-   中序遍历（LDR）  
    （1）先中序遍历左子树  
    （2）访问根结点  
    （3）中序遍历右子树
-   后序遍历（LRD）  
    （1）后序遍历左子树  
    （2）后序遍历右子树  
    （3）访问根结点
![[Pasted image 20221028201110.png]]
#### 广度优先遍历
-   层次遍历（迭代法）
 就是一层一层遍历，从上到下，从左到右
 
### 4.代码实现

#### 1.定义结点结构（二叉链表）
```c++
struct Tree_Node{
	char data;                 //数据域
	struct Tree_Node * left;    //左孩子
	struct Tree_Node * right;    //右孩子
};
```

```c++
struct Tree_Node{
	int data;
	Tree_Node * left;
	Tree_Node * right;
	Tree_Node(int x):data(x),left(NULL),right(NUll){};   //构造函数
}
```
#### 2.构造二叉树
```c++
//按照先序遍历的方式，构建我们的二叉树,输入的时候，我们要按照完全二叉树的形式输入，结点为空的位置，输入“#”
void CreateTree_Node(Tree_Node * & t){            //引用指针传入
	char str;
	cin>>str;
	if(str=='#'){
		t=NULL;        //空结点
	}
	else{
		t=new Tree_Node ;   //为结点开辟空间
		t->data=str; 
		CreateTree_Node(t->left);     //创建左子树      ！！递归套娃
		CreateTree_Node(t->right);     //创建右右子树   这里体现的就是根左右
	}
}
```

#### 3.先序遍历（中后序换个位置就行）
```c++
//先序遍历，递归实现
	void PreorderTraverse(Tree_Node * T){
		if(T){
			if(T->data!='#')            //这一步是为啥？？
			cout<<T->data<<" ";            //访问根结点
			PreorderTraverse(T->left);
			PreorderTraverse(T->right);
		}
	}
```


