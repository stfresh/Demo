### 为什么结点要采用malloc函数给其分配一块内存，而不直接用结构体定义？
#### 1.首先能不能定义？
可以。并且在全局定义的[结构体](https://so.csdn.net/so/search?q=%E7%BB%93%E6%9E%84%E4%BD%93&spm=1001.2101.3001.7020)变量，存储**全局数据区**；在函数内定义的结构体变量，存储在**栈区**；使用malloc函数申请空间来存放结构体变量，则该结构体变量存储在**堆空间**中。一般来说，链表都存在堆区。
如果我们用结构体定义1000个节点，然后创建链表当然可以，但是这样就失去了扩展性，**也即徒有链表的形式，不具备链表动态扩展的特点。**

#### 2.malloc怎么用
malloc的全称是memory allocation（动态内存分配），当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。返回类型是 **void* **类型。void* 表示未确定类型的指针。C,C++规定，void* 类型可以通过类型转换强制转换为任何其它类型的指针。
malloc只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的。一般意义上：我们习惯性的将其初始化为NULL。
```
struct List* ptr = (struct List*)malloc(sizeof(struct List));//创节点,强转类型
```


#### 3.malloc工作机制
malloc函数的实质体现在，它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。调用malloc函数时，它沿连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户请求的大小相等，另一块的大小就是剩下的字节）。接下来，将分配给用户的那块内存传给用户，并将剩下的那块（如果有的话）返回到连接表上。

调用free函数时，它将用户释放的内存块连接到空闲链上。到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段，那么空闲链上可能没有可以满足用户要求的片段了。于是，malloc函数请求延时，并开始在空闲链上翻箱倒柜地检查各内存片段，对它们进行整理，将相邻的小空闲块合并成较大的内存块。如果无法获得符合要求的内存块，malloc函数会返回NULL指针，因此在调用malloc动态申请内存块时，一定要进行**返回值的判断**。

#### 4.堆区空间记得释放
	free(p);      //释放的只是指针所指的内存内容，指针本身没有被删除
	p=NULL;      //所以要置空
