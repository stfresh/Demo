![[Pasted image 20221019154927.png|600]]
-   栈区(Stack) ：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。
-   堆区(Heap) ：一般由程序员分配释放（new-delete），若程序员不释放，程序结束时可能由OS收回
-   未初始化数据区(Uninitialized Data)： 存放未初始化的全局变量和静态变量
-   初始化数据区(Initialized Data)：存放已经初始化的全局变量和静态变量
-   程序代码区(Text)：存放函数体的二进制代码

代码区和数据区所占空间都是固定的，而且占用的空间非常小，那么看运行时消耗的内存**主要看可变部分**。

在可变部分中，栈区间的数据在代码块执行结束之后，系统会自动回收，而堆区间数据是需要程序员自己回收，所以也就是造成内存泄漏的发源地。

## 内存对齐
**跨平台的编程语言都需要做内存对齐，C++、C、Java、Python**。

**为什么会有内存对齐？**

主要是两个原因

1. 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。  
2.  硬件原因：经过内存对齐后，CPU访问内存的速度大大提升。
~~~ C++
struct node{
   int num;
   char cha;
}st;
int main() {
    int a[100];
    char b[100];
    cout << sizeof(int) << endl;
    cout << sizeof(char) << endl;
    cout << sizeof(a) << endl;
    cout << sizeof(b) << endl;
    cout << sizeof(st) << endl;
}
~~~
``` c++
4
1
400
100
8
```
CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。
![[Pasted image 20221019160133.png]]
![[Pasted image 20221019160204.png]]
1.  因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据
2.  CPU读取4，5，6，7处的四个字节数据
3.  合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据

此时一共需要两次寻址，一次合并的操作。(相对来说计算机内存资源一般都是充足的，更希望的是提高运行速度。)