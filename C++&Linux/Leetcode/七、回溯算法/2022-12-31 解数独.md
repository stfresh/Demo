[力扣题目链接](https://leetcode.cn/problems/sudoku-solver/)
编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1.  数字 `1-9` 在每一行只能出现一次。
2.  数字 `1-9` 在每一列只能出现一次。
3.  数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1：**
![[Pasted image 20221231192119.png]]
```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
```
![[Pasted image 20221231192137.png]]
-   `board[i][j]` 是一位数字或者 `'.'`
-   题目数据 **保证** 输入数独仅有一个解
### 分析
	1.此题和N皇后有点类似，也是遍历一个盘，但是区别在于，N皇后我们可以使用一层for对一行进行遍历，利用递归对其他行进行操作，这是因为N皇后每行只需要放一个皇后
	2.而对于解数独问题，我们每个格子上都要填数，如果只用一个for无法完成，所以我们需要二维递归

### 代码
```c++
class Solution {
public:
    bool isvalid(vector<vector<char>>& board,int& i,int& j,char k){
        //1.判断当前行有没有重复的k数
        for(int c = 0; c < board[0].size();c++){
            if(board[i][c] == k)    return false;
        }
        //2.判断当前列有没有重复的k数
         for(int r = 0; r < board.size();r++){
            if(board[r][j] == k)    return false;
        }
        //3.判断当前3×3格子中有没有重复的k数
        int strow = (i / 3) * 3;
        int stclo = (j / 3) * 3;
        for(int i = strow ; i < strow + 3; i++){
            for(int j = stclo; j <stclo + 3; j++){
                if(board[i][j] == k)    return false;
            }
        }
        return true;
    }
    bool backtracking(vector<vector<char>>& board){
        for(int i = 0; i < board.size(); i++){ //遍历行
            for(int j = 0;j < board[0].size(); j++){//遍历列
	            //找到空白处
                if(board[i][j] == '.'){
	                //测试9个数字哪个合法
                    for(char k = '1'; k <= '9'; k++){
	                    //如果合法，填入并递归
                        if(isvalid(board,i,j,k)){
                            board[i][j] = k;
                            bool next = backtracking(board);
                            if(next)    return true;
                            board[i][j] = '.';
                        }
                    }
                    //如果9个数字都不合适，那么我们就回溯
                    return false;
                }
            }
        }
        //填满后，最后一个双层for会发现没有空白，那么就是找到了结果，返回true，上一层收到true也返回，最后一层层返回结果
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
```