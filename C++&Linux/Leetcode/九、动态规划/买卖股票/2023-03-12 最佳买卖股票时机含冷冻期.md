[309. 最佳买卖股票时机含冷冻期 - 力扣（Leetcode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)
给定一个整数数组`prices`，其中第  `prices[i]` 表示第 `_i_` 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

-   卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**
```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**
```
输入: prices = [1]
输出: 0
```

### 和[[2023-03-10 买卖股票的最佳时机Ⅱ动规]]区别在于本题有贤者模式，即卖出之后，不能在第二天买入，要休息一天


### 动态规划
#### 1.  确定dp数组以及下标的含义
$dp[i][j]$，第i天状态为j，所剩的最多现金为$dp[i][j]$。
这里分四种状态0，1，2，3

状态0：表示股票持有状态（可能今天买的，也可能是之前就买了）

状态1：表示保持卖出的状态，就是不持有的情况**但是这里分两种情况**
	1.股票是前两天卖的，所以今天刚好是度过冷冻期的第一天
	2.昨天就是卖出状态的，今天啥也没干

状态2：股票是今天卖出的，**这里单独列出今天卖出**是因为如果归为状态1的话很模糊，不知道股票到底是怎么个法没地

状态3：今天是冷冻期

#### 2.  确定递推公式

##### 0.持有股票

今天买或者前几天早就有了，,**①如果是今天买的，还得考虑今天是不是冷冻期！！！所以这里就是利用状态1，那么今天 i 利用 i-1 的状态 1 ，那今天 i 肯定不是冷冻期**；②**还有一种可能就是昨天就是冷冻期，就是状态3 **
$dp[i][0]=max(dp[i-1][0],max(dp[i-1][3]-price[i],dp[i-1][1]-price[i]))$

##### 1.保持卖出状态

前一天就是状态1，或者前一天是冷冻期
$dp[i][1] = max(dp[i-1][1],dp[i-1][3])$

##### 2.今天卖出股票

那就只有一种可能，昨天就是持有股票

$dp[i][2] = dp[i-1][0]+price[i]$

##### 3.今天是冷冻期
只有一种可能，昨天卖了,那就是状态2
$dp[i][3]=dp[i-1][2]$

#### 3.  dp数组如何初始化
$dp[0][0]=-price[0]$
$dp[0][1]=0$
其他都是零

#### 4. 遍历顺序（从前往后就行）


```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
       vector<vector<int>> dp(prices.size(),vector<int>(4,0));
       dp[0][0] = -prices[0];
       for(int i = 1;i < prices.size();i++){
           for(int j = 0;j < 4; j++){
              dp[i][0]=max(dp[i-1][0],max(dp[i-1][3]-prices[i],dp[i-1][1]-prices[i]));
              dp[i][1] = max(dp[i-1][1],dp[i-1][3]);
              dp[i][2] = dp[i-1][0]+prices[i];
              dp[i][3]=dp[i-1][2];
           }
       }
       return max(dp[prices.size()-1][1],max(dp[prices.size()-1][2],dp[prices.size()-1][3]));
    }
};
```